
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>proveit._core_.known_truth &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for proveit._core_.known_truth</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A KnownTruth represents an expression that has been proven to be a true</span>
<span class="sd">statement.  A KnownTruth wraps an Expression (acting like the Expression</span>
<span class="sd">in many ways via overloading __getattr__) but also has a list of assumptions</span>
<span class="sd">and its proof (as a Proof object, which may be updated if a newer proof,</span>
<span class="sd">with possibly fewer assumptions, suffices).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">proveit._core_.expression</span> <span class="k">import</span> <span class="n">Expression</span>
<span class="kn">from</span> <span class="nn">proveit._core_._unique_data</span> <span class="k">import</span> <span class="n">meaningData</span><span class="p">,</span> <span class="n">styleData</span>
<span class="kn">from</span> <span class="nn">.defaults</span> <span class="k">import</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">_ExprProofs</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Stores a set of proofs for a particular expression under any set</span>
<span class="sd">    of assumptions.  We maintain such sets so that we can update</span>
<span class="sd">    KnownTruth proofs appropriately when a particular proof has been</span>
<span class="sd">    disabled.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">all_expr_proofs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># map expressions to expression proofs</span>
        
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
    
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newproof</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert a new proof for the expression, maintaining sorted order</span>
<span class="sd">        in the proof size (number of steps).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Proof</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newproof</span><span class="p">,</span> <span class="n">Proof</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">newproof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newproof</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldproof</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Proof</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oldproof</span><span class="p">,</span> <span class="n">Proof</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">oldproof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">oldproof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">(),</span> <span class="s2">&quot;Should only remove unusable proofs&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">oldproof</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">bestProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">knowntruth</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the best proof applicable to the knowntruth that is usable</span>
<span class="sd">        (or None if there aren&#39;t any that are usable).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">knowntruth</span><span class="p">,</span> <span class="n">KnownTruth</span><span class="p">)</span>
        <span class="n">best_unusable_proof</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fewestSteps</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">proof</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proofs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">knowntruth</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">(),</span> <span class="s1">&#39;unusable proofs should have been removed&#39;</span>
                
                <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">numSteps</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">fewestSteps</span><span class="p">:</span>
                    <span class="n">fewestSteps</span> <span class="o">=</span> <span class="n">proof</span><span class="o">.</span><span class="n">numSteps</span><span class="p">()</span>
                    <span class="n">best_unusable_proof</span> <span class="o">=</span> <span class="n">proof</span>
        <span class="k">return</span> <span class="n">best_unusable_proof</span> <span class="c1"># the proof with the fewest steps that is applicable</span>

            
<div class="viewcode-block" id="KnownTruth"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth">[docs]</a><span class="k">class</span> <span class="nc">KnownTruth</span><span class="p">:</span>
    <span class="c1"># lookup_dict maps each Expression to a set of KnownTruths for proving the </span>
    <span class="c1"># Expression under various assumptions.</span>
    <span class="n">lookup_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="c1"># (KnownTruth, default assumptions) pairs for which deriveSideEffects has been called.  </span>
    <span class="c1"># We track this to make sure we didn&#39;t miss anything while automation was disabled and then re-enabled.</span>
    <span class="n">sideeffect_processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="c1"># Call the beginProof method to begin a proof of a Theorem.</span>
    <span class="n">theoremBeingProven</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Theorem being proven.</span>
    <span class="n">hasBeenProven</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Has the theoremBeingProven been proven yet in this session?  </span>
                         <span class="c1"># Goes from None to False (after beginning a proof and disabling Theorems that cannot be used)</span>
                         <span class="c1"># to True (when there is a legitimate proof).</span>
    <span class="c1"># Set of theorems/packages that are presumed to be True for the purposes of the proof being proven:</span>
    <span class="n">presumingTheoremNamess</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># set of full names of presumed theorems when in use</span>
    <span class="n">presumingPrefixes</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># set of context names or full theorem names when in use.</span>
    <span class="n">qedInProgress</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># set to true when &quot;%qed&quot; is in progress</span>

    <span class="c1"># KnownTruths for which deriveSideEffects is in progress, tracked to prevent infinite</span>
    <span class="c1"># recursion when deducing side effects after something is proven.</span>
    <span class="n">in_progress_to_derive_sideeffects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> 

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clear_</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Clear all references to Prove-It information in</span>
<span class="sd">        the KnownTruth jurisdiction.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">lookup_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">sideeffect_processed</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">hasBeenProven</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">presumingTheorems</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">presumingPrefixes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">qedInProgress</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">KnownTruth</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Unexpected remnant &#39;in_progress_to_derive_sideeffects&#39; items (should have been temporary)&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a KnownTruth with the given Expression, set of assumptions.  These</span>
<span class="sd">        should not be created manually but rather through the creation of Proofs which should</span>
<span class="sd">        be done indirectly via Expression/KnownTruth derivation-step methods.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">Proof</span>
        <span class="c1"># do some type checking</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The expression (expr) of a KnownTruth should be an Expression&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assumption</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Each assumption should be an Expression&#39;</span><span class="p">)</span>
        
        <span class="c1"># note: these contained expressions are subject to style changes on a KnownTruth instance basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="c1"># store the assumptions as an ordered list (with the desired order for display)</span>
        <span class="c1"># and an unordered set (for convenience when checking whether one set subsumes another).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assumptionsSet</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>

        <span class="c1"># The meaning data is shared among KnownTruths with the same structure disregarding style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span> <span class="o">=</span> <span class="n">meaningData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_unique_rep</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span> <span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_meaning_id</span><span class="p">)))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="p">,</span> <span class="s1">&#39;_exprProofs&#39;</span><span class="p">):</span>
            <span class="c1"># create or assign the _ExprProofs object for storing all proofs</span>
            <span class="c1"># for this KnownTruth&#39;s expr (under any set of assumptions).</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">in</span> <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="p">:</span>
                <span class="n">exprProofs</span> <span class="o">=</span> <span class="n">_ExprProofs</span><span class="o">.</span><span class="n">all_expr_proofs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exprProofs</span> <span class="o">=</span> <span class="n">_ExprProofs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_exprProofs</span> <span class="o">=</span> <span class="n">exprProofs</span>
            <span class="c1"># Initially, _proof is None but will be assigned and updated via _addProof()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># The style data is shared among KnownTruths with the same structure and style.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span> <span class="o">=</span> <span class="n">styleData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_unique_rep</span><span class="p">(</span><span class="k">lambda</span> <span class="n">expr</span> <span class="p">:</span> <span class="nb">hex</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_style_id</span><span class="p">)))</span>
        
        <span class="c1"># establish some parent-child relationships (important in case styles are updated)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="p">)</span>
        
        <span class="c1"># reference this unchanging data of the unique &#39;meaning&#39; data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_unique_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exprProofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_exprProofs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_styleData</span><span class="o">.</span><span class="n">_unique_id</span>
        
        <span class="c1"># The _proof can change so it must be accessed via indirection into self._meaningData</span>
        <span class="c1"># (see proof() method).</span>
    
    <span class="k">def</span> <span class="nf">_generate_unique_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objectRepFn</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate a unique representation string using the given function to obtain representations of other referenced Prove-It objects.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">objectRepFn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">objectRepFn</span><span class="p">(</span><span class="n">assumption</span><span class="p">)</span> <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extractReferencedObjIds</span><span class="p">(</span><span class="n">unique_rep</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a unique representation string, returns the list of representations</span>
<span class="sd">        of Prove-It objects that are referenced.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Everything between the punctuation, &#39;;&#39;, &#39;[&#39;, &#39;]&#39;, &#39;,&#39;, is a represented object.</span>
        <span class="n">objIds</span> <span class="o">=</span>  <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;|\[|,|\]&quot;</span><span class="p">,</span><span class="n">unique_rep</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">objId</span> <span class="k">for</span> <span class="n">objId</span> <span class="ow">in</span> <span class="n">objIds</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objId</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>           
                
<div class="viewcode-block" id="KnownTruth.deriveSideEffects"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.deriveSideEffects">[docs]</a>    <span class="k">def</span> <span class="nf">deriveSideEffects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Derive any side-effects that are obvious consequences arising from this truth.</span>
<span class="sd">        Called after the corresponding Proof is complete.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">ProofFailure</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">defaults</span><span class="o">.</span><span class="n">automation</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># automation disabled</span>
        <span class="c1"># Sort the assumptions according to hash key so that sets of assumptions</span>
        <span class="c1"># are unique for determining which side-effects have been processed already.</span>
        <span class="n">sorted_assumptions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">expr</span> <span class="p">:</span> <span class="nb">hash</span><span class="p">(</span><span class="n">expr</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sorted_assumptions</span><span class="p">)</span> <span class="ow">in</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">sideeffect_processed</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># has already been processed</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="p">:</span>
            <span class="c1"># avoid infinite recursion by using in_progress_to_deduce_sideeffects</span>
            <span class="n">KnownTruth</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sideEffect</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">sideEffects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="c1"># Attempt each side-effect derivation, specific to the</span>
                    <span class="c1"># type of Expression.</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># use the default assumptions which are temporarily set to the</span>
                        <span class="c1"># assumptions utilized in the last derivation step.</span>
                        <span class="n">sideEffect</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">)</span>     
                    <span class="k">except</span> <span class="n">ProofFailure</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Side effect failure for </span><span class="si">%s</span><span class="s2">, while running </span><span class="si">%s</span><span class="s2">: &quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sideEffect</span><span class="p">))</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">KnownTruth</span><span class="o">.</span><span class="n">in_progress_to_derive_sideeffects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>        
            <span class="n">KnownTruth</span><span class="o">.</span><span class="n">sideeffect_processed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">sorted_assumptions</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">KnownTruth</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_meaning_id</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span> <span class="c1"># other must be an Expression to be equal to self</span>
    
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaning_id</span>
        
<div class="viewcode-block" id="KnownTruth.beginProof"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.beginProof">[docs]</a>    <span class="k">def</span> <span class="nf">beginProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theorem</span><span class="p">,</span> <span class="n">presuming</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">justRecordPresumingInfo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Begin a proof for a theorem.  Only use other theorems that are in </span>
<span class="sd">        the presuming list of theorems/packages or theorems that are required,</span>
<span class="sd">        directly or indirectly, in proofs of theorems that are explicitly </span>
<span class="sd">        listed (these are implicitly presumed).  If there exists any </span>
<span class="sd">        presumed theorem that has a direct or indirect dependence upon this </span>
<span class="sd">        theorem then a CircularLogic exception is raised. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.context</span> <span class="k">import</span> <span class="n">Context</span><span class="p">,</span> <span class="n">ContextException</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Theorem</span>
        <span class="k">if</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProofInitiationFailure</span><span class="p">(</span><span class="s2">&quot;May only beginProof once per Python/IPython session.  Restart the notebook to restart the proof.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theorem</span><span class="p">,</span> <span class="n">Theorem</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Only begin a proof for a Theorem&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theorem</span><span class="o">.</span><span class="n">provenTruth</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent theorem for the KnownTruth in beginProof call&#39;</span><span class="p">)</span>
                
        <span class="c1"># Note: all previous theorems of the context are presumed automatically.</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">theorem</span><span class="o">.</span><span class="n">context</span>
        <span class="n">num_prev_thms</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of previous theorems within the context</span>
        <span class="k">for</span> <span class="n">prev_thm_name</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">theoremNames</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">prev_thm_name</span> <span class="o">==</span> <span class="n">theorem</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">break</span> <span class="c1"># concludes all &quot;previous&quot; theorems of the context</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>  <span class="n">prev_thm_name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">presuming</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Do not explicitly presuming any previous theorems of the context.  They are automatically presumed.&quot;</span><span class="p">)</span>
            <span class="n">num_prev_thms</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># split the presuming information into specific theorems (which are transitively presumed)</span>
        <span class="c1"># and entire contexts (which are not transitively presumed only applies to theorems of</span>
        <span class="c1"># the other context that do not presume this one).</span>
        <span class="n">explicitly_presumed_thm_names</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of theorem name strings</span>
        <span class="n">presumed_context_names</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of context name strings</span>
        <span class="k">for</span> <span class="n">presumption_name</span> <span class="ow">in</span> <span class="n">presuming</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">presumption_name</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">context_name</span><span class="p">,</span> <span class="n">theorem_name</span> <span class="o">=</span> <span class="n">presumption_name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">getContext</span><span class="p">(</span><span class="n">context_name</span><span class="p">)</span>
                    <span class="c1"># Ensure we load the theorem and derive its automatic side-effects</span>
                    <span class="c1"># for these explicitly presumed theorems (but not the indirectly</span>
                    <span class="c1"># presumed ones).</span>
                    <span class="n">context</span><span class="o">.</span><span class="n">getTheorem</span><span class="p">(</span><span class="n">theorem_name</span><span class="p">)</span>
                    <span class="c1"># it is a theorem</span>
                    <span class="n">explicitly_presumed_thm_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">presumption_name</span><span class="p">)</span> <span class="c1"># append as a string</span>
                    <span class="k">continue</span> <span class="c1"># continue to the next thing</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">ContextException</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                    <span class="k">pass</span>
            <span class="c1"># it must not be a theorem; it should be a Context.</span>
            <span class="n">presumed_context_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">presumption_name</span><span class="p">)</span> <span class="c1"># not a theorem; must be a context</span>
        
        <span class="c1"># record the explicitly presumed theorems</span>
        <span class="n">theorem</span><span class="o">.</span><span class="n">recordPresumedContexts</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">presumed_context_names</span><span class="p">))</span>
        <span class="n">theorem</span><span class="o">.</span><span class="n">recordPresumedTheorems</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">explicitly_presumed_thm_names</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">justRecordPresumingInfo</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recorded &#39;presuming&#39; information&quot;</span><span class="p">)</span>
        
        <span class="c1"># The full list of presumed theorems includes all previous theorems</span>
        <span class="c1"># of the context and all indirectly presumed theorems via transitivity</span>
        <span class="c1"># (a presumption of a presumption is a presumption).</span>
        <span class="n">presumed_theorem_names</span> <span class="o">=</span> <span class="n">theorem</span><span class="o">.</span><span class="n">getAllPresumedTheoremNames</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">presumed_theorem_names</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">CircularLogic</span>
            <span class="c1"># extra sanity check (should be caught within getAllPresumedTheoremNames)</span>
            <span class="k">raise</span> <span class="n">CircularLogic</span><span class="p">(</span><span class="n">theorem</span><span class="p">,</span> <span class="n">theorem</span><span class="p">)</span>
        
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span> <span class="o">=</span> <span class="n">theorem</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">presumingTheoremNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">presumed_theorem_names</span><span class="p">)</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">presumingPrefixes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">presumed_context_names</span><span class="p">)</span>
        <span class="n">Theorem</span><span class="o">.</span><span class="n">updateUsability</span><span class="p">()</span>
        
        <span class="c1"># change KnownTruth.hasBeenProven</span>
        <span class="c1"># from None to False -- we can now test to see if </span>
        <span class="c1"># we have a proof for KnownTruth.theoremBeingProven</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">hasBeenProven</span> <span class="o">=</span> <span class="kc">False</span>        
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # check to see if the theorem was already proven before we started</span>
<span class="sd">        for proof in theorem._possibleProofs:</span>
<span class="sd">            if proof.isUsable():</span>
<span class="sd">                proof.provenTruth._recordBestProof(proof)</span>
<span class="sd">                return self.expr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkIfReadyForQED</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="c1"># already proven</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">presumed_context_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Presuming theorems in </span><span class="si">%s</span><span class="s2"> (except any that presume this theorem).&quot;</span><span class="o">%</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">presumed_context_names</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">explicitly_presumed_thm_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">theorem_or_theorems</span> <span class="o">=</span> <span class="s1">&#39;theorem&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">explicitly_presumed_thm_names</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;theorems&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Presuming </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> (applied transitively).&quot;</span><span class="o">%</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">thm</span><span class="p">)</span> <span class="k">for</span> <span class="n">thm</span> <span class="ow">in</span> <span class="n">explicitly_presumed_thm_names</span><span class="p">)),</span> <span class="n">theorem_or_theorems</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num_prev_thms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">theorem_or_theorems</span> <span class="o">=</span> <span class="s1">&#39;theorem&#39;</span> <span class="k">if</span> <span class="n">num_prev_thms</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;theorems&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Presuming previous </span><span class="si">%s</span><span class="s2"> (applied transitively).&quot;</span><span class="o">%</span><span class="n">theorem_or_theorems</span><span class="p">)</span>
        <span class="n">theorem</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_unusableProof</span> <span class="o">=</span> <span class="n">theorem</span> <span class="c1"># can&#39;t use itself to prove itself</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span></div>
    
    <span class="k">def</span> <span class="nf">_qed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Complete a proof that began via `beginProof`, entering it into</span>
<span class="sd">        the certification database.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;No theorem being proven; cannot call qed method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">!=</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;qed does not match the theorem being proven&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;qed proof should not have any remaining assumptions&#39;</span><span class="p">)</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">qedInProgress</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span>
                <span class="n">proof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">raiseUnusableProof</span><span class="p">()</span>
            <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span><span class="o">.</span><span class="n">recordProof</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">KnownTruth</span><span class="o">.</span><span class="n">qedInProgress</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">proof</span>

<div class="viewcode-block" id="KnownTruth.proof"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.proof">[docs]</a>    <span class="k">def</span> <span class="nf">proof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the most up-to-date proof of this KnownTruth.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_proof</span></div>
    
<div class="viewcode-block" id="KnownTruth.isUsable"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.isUsable">[docs]</a>    <span class="k">def</span> <span class="nf">isUsable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns True iff this KnownTruth has a &quot;usable&quot; proof.  Proofs</span>
<span class="sd">        may be unusable when proving a theorem that is restricted with</span>
<span class="sd">        respect to which theorems may be used (to avoid circular logic).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="KnownTruth.isSufficient"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.isSufficient">[docs]</a>    <span class="k">def</span> <span class="nf">isSufficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True iff the given assumptions satisfy the KnownTruth; </span>
<span class="sd">        the KnownTruth is usable and requires a subset of the given assumptions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isUsable</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KnownTruth.asTheoremOrAxiom"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.asTheoremOrAxiom">[docs]</a>    <span class="k">def</span> <span class="nf">asTheoremOrAxiom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Assuming this KnownTruth represents a Theorem or Axiom, return </span>
<span class="sd">        the Theorem or Axiom object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Theorem</span><span class="p">,</span> <span class="n">Axiom</span>
        <span class="c1"># Get the theorem associated with the KnownTruth (or raise an exception if there is none)</span>
        <span class="k">if</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proof</span><span class="p">,</span> <span class="n">Theorem</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proof</span><span class="p">,</span> <span class="n">Axiom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">proof</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;KnownTruth does not represent a theorem or axiom.&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KnownTruth.printRequirements"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.printRequirements">[docs]</a>    <span class="k">def</span> <span class="nf">printRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Provided that this KnownTruth is known to represent a proven theorem,</span>
<span class="sd">        print the set of axioms that are required directly or indirectly in</span>
<span class="sd">        its proof as well as any required theorems that are unproven (if it</span>
<span class="sd">        has not yet been proven completely).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.certify</span> <span class="k">import</span> <span class="n">isFullyProven</span><span class="p">,</span> <span class="n">allRequirements</span>
        <span class="c1"># print the required axioms and unproven theorems </span>
        <span class="n">requiredAxioms</span><span class="p">,</span> <span class="n">requiredTheorems</span> <span class="o">=</span> <span class="n">allRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">requiredAxioms</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">axiom</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">requiredTheorems</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">isFullyProven</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;certification database is corrupt&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Theorem is fully proven!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">requiredTheorems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">isFullyProven</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;certification database is corrupt&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Unproven theorems:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">theorem</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">requiredTheorems</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">theorem</span><span class="p">)</span></div>

<div class="viewcode-block" id="KnownTruth.printDependents"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.printDependents">[docs]</a>    <span class="k">def</span> <span class="nf">printDependents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Provided that this KnownTruth is known to represent a theorem or axiom,</span>
<span class="sd">        print all theorems that are known to depend on it directly or indirectly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.certify</span> <span class="k">import</span> <span class="n">allDependents</span>
        <span class="n">dependents</span> <span class="o">=</span> <span class="n">allDependents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">theorem</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dependents</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">theorem</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_discardProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Discard a disabled proof as an option in the _ExprProofs object.</span>
<span class="sd">        Don&#39;t change self._meaningData._proof, now, however.  It will be updated</span>
<span class="sd">        in due time and may be replaced with a proof that hasn&#39;t</span>
<span class="sd">        been disabled.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exprProofs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">proof</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_addProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newproof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        After a Proof is finished being constructed, record the best</span>
<span class="sd">        proof for the KnownTruth which may be the new proof, &#39;proof&#39;,</span>
<span class="sd">        or a pre-existing one.  Update all KnownTruths</span>
<span class="sd">        with the same &#39;truth&#39; expression that should be updated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#print &#39;record best&#39;, self.expr, &#39;under&#39;, self.assumptions</span>
        <span class="c1"># update KnownTruth.lookup_dict and use find all of the KnownTruths</span>
        <span class="c1"># with this expr to see if the proof should be updated with the new proof.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">newproof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span>
            <span class="c1"># Don&#39;t bother with a disabled proof unless it is the only</span>
            <span class="c1"># proof.  in that case, we record it so we can generate a useful</span>
            <span class="c1"># error message via raiseUnusableProof(..).</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="n">newproof</span>
            <span class="k">return</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_exprProofs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">newproof</span><span class="p">)</span>
    
        <span class="c1"># Check to see if the new proof is applicable to any other KnownTruth.</span>
        <span class="c1"># It can replace an old proof if it became unusable or if the newer one uses fewer steps.</span>
        <span class="n">expr_known_truths</span> <span class="o">=</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">lookup_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">expr_known_truths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">expr_known_truth</span> <span class="ow">in</span> <span class="n">expr_known_truths</span><span class="p">:</span>
            <span class="c1"># Is &#39;proof&#39; applicable to &#39;expr_known_truth&#39;?</span>
            <span class="k">if</span> <span class="n">newproof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">expr_known_truth</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="p">):</span>
                <span class="c1"># replace if there was no pre-existing usable proof or the new proof has fewer steps</span>
                <span class="n">preexisting_proof</span> <span class="o">=</span> <span class="n">expr_known_truth</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">preexisting_proof</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">preexisting_proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">()</span> <span class="ow">or</span> <span class="n">newproof</span><span class="o">.</span><span class="n">numSteps</span><span class="p">()</span><span class="o">&lt;</span><span class="n">preexisting_proof</span><span class="o">.</span><span class="n">numSteps</span><span class="p">():</span>
                    <span class="n">expr_known_truth</span><span class="o">.</span><span class="n">_updateProof</span><span class="p">(</span><span class="n">newproof</span><span class="p">)</span> <span class="c1"># replace an old proof</span>
    
    <span class="k">def</span> <span class="nf">_reviseProof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        After a proof and its dependents have been disabled, we will see</span>
<span class="sd">        if there is another proof that is usable (see Proof.disable()).</span>
<span class="sd">        Return True iff the proof actually changed to something usable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updateProof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exprProofs</span><span class="o">.</span><span class="n">bestProof</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>             
        
        
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def _recordBestProof(self, newProof):</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        After a Proof is finished being constructed, check to see if</span>
<span class="sd">        any proofs for this KnownTruth are obsolete; the new proof</span>
<span class="sd">        might make a previous one obsolete, or it may be born</span>
<span class="sd">        obsolete itself.  A proof is obsolete if there exists a KnownTruth</span>
<span class="sd">        with a subset of the assumptions required for that proof, or with</span>
<span class="sd">        the same set of assumptions but fewer steps.  A tie goes to the</span>
<span class="sd">        new proof, but note that the step number comparison will prevent</span>
<span class="sd">        anything cyclic (since a proof for a KnownTruth that requires that</span>
<span class="sd">        same KnownTruth as a dependent will necessarily include the</span>
<span class="sd">        number of steps of the original proof plus more).</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        self._updateProof(self._exprProofs.bestProof(self))</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        from proof import Theorem</span>
<span class="sd">        if not self.expr in KnownTruth.lookup_dict:</span>
<span class="sd">            # the first KnownTruth for this Expression</span>
<span class="sd">            self._proof = newProof</span>
<span class="sd">            KnownTruth.lookup_dict[self.expr] = [self]</span>
<span class="sd">            return</span>
<span class="sd">        if not newProof.isUsable():</span>
<span class="sd">            # if it is not usable, we&#39;re done.</span>
<span class="sd">            if self._proof is None:</span>
<span class="sd">                # but first set _proof to the newProof if there </span>
<span class="sd">                # is not another one.</span>
<span class="sd">                self._proof = newProof</span>
<span class="sd">            return</span>
<span class="sd">        keptTruths = []</span>
<span class="sd">        bornObsolete = False</span>
<span class="sd">        for other in KnownTruth.lookup_dict[self.expr]:</span>
<span class="sd">            if self.assumptionsSet == other.assumptionsSet:</span>
<span class="sd">                if not other._proof.isUsable():</span>
<span class="sd">                    # use the new proof since the old one is unusable.</span>
<span class="sd">                    other._updateProof(newProof)</span>
<span class="sd">                elif newProof.numSteps &lt;= other._proof.numSteps:</span>
<span class="sd">                    if newProof.requiredProofs != other._proof.requiredProofs:</span>
<span class="sd">                        # use the new (different) proof that does the job as well or better</span>
<span class="sd">                        if isinstance(newProof, Theorem):</span>
<span class="sd">                            # newer proof is a theorem; record the existing proof as a possible proof for that theorem</span>
<span class="sd">                            newProof._possibleProofs.append(other._proof)</span>
<span class="sd">                        other._updateProof(newProof)</span>
<span class="sd">                else:</span>
<span class="sd">                    # the new proof was born obsolete, taking more steps than an existing one</span>
<span class="sd">                    if isinstance(other._proof, Theorem):</span>
<span class="sd">                        # the older proof is a theorem, record the new proof as a possible proof for that theorem</span>
<span class="sd">                        other._proof._possibleProofs.append(newProof)</span>
<span class="sd">                    self._proof = other._proof # use an old proof that does the job better</span>
<span class="sd">                    keptTruths.append(other)</span>
<span class="sd">                    bornObsolete = True</span>
<span class="sd">            elif self.assumptionsSet.issubset(other.assumptionsSet):</span>
<span class="sd">                # use the new proof that does the job better</span>
<span class="sd">                other._updateProof(newProof) </span>
<span class="sd">            elif self.assumptionsSet.issuperset(other.assumptionsSet) and other._proof.isUsable():</span>
<span class="sd">                # the new proof was born obsolete, requiring more assumptions than an existing one</span>
<span class="sd">                self._proof = other._proof # use an old proof that does the job better</span>
<span class="sd">                keptTruths.append(other)</span>
<span class="sd">                bornObsolete = True</span>
<span class="sd">            else:</span>
<span class="sd">                # &#39;other&#39; uses a different, non-redundant set of assumptions or </span>
<span class="sd">                # uses a subset of the assumptions but is unusable</span>
<span class="sd">                keptTruths.append(other)</span>
<span class="sd">        if not bornObsolete:</span>
<span class="sd">            if KnownTruth.theoremBeingProven is not None:</span>
<span class="sd">                if not KnownTruth.qedInProgress and len(self.assumptions)==0 and self.expr == KnownTruth.theoremBeingProven.provenTruth.expr:</span>
<span class="sd">                    if not KnownTruth.hasBeenProven:</span>
<span class="sd">                        KnownTruth.hasBeenProven = True</span>
<span class="sd">                        print &#39;%s has been proven. &#39;%self.asTheoremOrAxiom().name, r&#39;Now simply execute &quot;%qed&quot;.&#39;</span>
<span class="sd">            self._proof = newProof</span>
<span class="sd">            keptTruths.append(self)</span>
<span class="sd">        # Remove the obsolete KnownTruths from the lookup_dict -- SHOULD ACTUALLY KEEP OLD PROOFS IN CASE ONE IS DISABLED -- TODO</span>
<span class="sd">        KnownTruth.lookup_dict[self.expr] = keptTruths</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_updateProof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newProof</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Update the proof of this KnownTruth.  Return True iff the proof actually changed to something usable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">meaningData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meaningData</span>
        
        <span class="k">if</span> <span class="n">newProof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no usable proof.  </span>
            <span class="c1"># no need to update dependencies because that would have already been done when the proof was disabled.</span>
            <span class="k">if</span> <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">(),</span> <span class="s2">&quot;should not update to an unusable new proof if the old one was usable&quot;</span>
            <span class="k">return</span> <span class="kc">False</span> <span class="c1"># did not change to something usable</span>
        <span class="k">assert</span> <span class="n">newProof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">(),</span> <span class="s2">&quot;Should not update with an unusable proof&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkIfReadyForQED</span><span class="p">(</span><span class="n">newProof</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no previous dependents to update</span>
            <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="n">newProof</span>
            <span class="k">return</span> <span class="kc">True</span> <span class="c1"># new usable proof</span>
        <span class="k">elif</span> <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="o">==</span> <span class="n">newProof</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span> <span class="c1"># no change</span>
                
        <span class="c1"># swap out the old proof for the new proof in all dependencies</span>
        <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span><span class="o">.</span><span class="n">_updateDependencies</span><span class="p">(</span><span class="n">newProof</span><span class="p">)</span>
        <span class="n">meaningData</span><span class="o">.</span><span class="n">_proof</span> <span class="o">=</span> <span class="n">newProof</span> <span class="c1"># set to the new proof</span>
        
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span> <span class="nf">_checkIfReadyForQED</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">()</span> <span class="ow">and</span> <span class="n">proof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">==</span><span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">hasBeenProven</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># check if we have a usable proof for the theorem being proven</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">qedInProgress</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">==</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">expr</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">hasBeenProven</span><span class="p">:</span>
                        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">hasBeenProven</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> has been proven. &#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">asTheoremOrAxiom</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;Now simply execute &quot;%qed&quot;.&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        KnownTruths should be read-only objects.  Attributes may be added, however; for example,</span>
<span class="sd">        the &#39;png&#39; attribute which will be added whenever it is generated).   Also,</span>
<span class="sd">        _proof is an exception which can be updated internally.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">!=</span> <span class="s1">&#39;_proof&#39;</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Attempting to alter read-only value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>    

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The KnownTruth aquires the attributes of its Expression, so it will act</span>
<span class="sd">        like the Expression except it has additional (or possibly overridden) attributes.</span>
<span class="sd">        When accessing functions of the Expression, if that function has &#39;assumptions&#39;</span>
<span class="sd">        as a keyword argument, the assumptions of the KnownTruth are automatically</span>
<span class="sd">        included.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span>
        <span class="kn">import</span> <span class="nn">inspect</span>
        
        <span class="c1"># called only if the attribute does not exist in KnownTruth directly</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;png&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Do not use the Expression version of the &#39;png&#39; attribute.&quot;</span><span class="p">)</span> 
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;assumptions&#39;</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="c1"># The attribute is a callable function with &#39;assumptions&#39; as an argument.</span>
            <span class="c1"># Automatically include the KnownTruth assumptions.</span>

            <span class="c1"># note, index zero is self.</span>
            <span class="n">assumptionsIndex</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            
            <span class="k">def</span> <span class="nf">call_method_with_known_truth_assumptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">assumptionsIndex</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                    <span class="n">assumptions</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">assumptionsIndex</span><span class="p">]</span>
                    <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>                    
                    <span class="n">assumptions</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">assumptionsIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">assumptions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;assumptions&#39;</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span><span class="p">)</span>
                    <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                    <span class="n">assumptions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;assumptions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">call_method_with_known_truth_assumptions</span>
        
        <span class="k">return</span> <span class="n">attr</span>
            
    
    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The KnownTruth aquires the attributes of its Expression as well as its</span>
<span class="sd">        own attributes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)))</span>

<div class="viewcode-block" id="KnownTruth.withMatchingStyles"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.withMatchingStyles">[docs]</a>    <span class="k">def</span> <span class="nf">withMatchingStyles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Alter the styles of the KnownTruth expression and any of its assumptions</span>
<span class="sd">        to match the given styles.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">withMatchingStyle</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># storing the assumptions in a trivial dictionary will be useful for popping them out.</span>
        <span class="n">assumptions_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">assumption</span><span class="p">:</span><span class="n">assumption</span> <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assumption</span> <span class="ow">in</span> <span class="n">assumptions_dict</span><span class="p">:</span>
                <span class="n">assumption</span><span class="o">.</span><span class="n">withMatchingStyle</span><span class="p">(</span><span class="n">assumptions_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">assumption</span><span class="p">))</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">proof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">_style_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_style_id</span><span class="p">:</span>
                <span class="n">proof</span><span class="o">.</span><span class="n">provenTruth</span><span class="o">.</span><span class="n">withMatchingStyles</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="KnownTruth.findKnownTruth"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.findKnownTruth">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">findKnownTruth</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">assumptionsSet</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Try to find a KnownTruth for this expression that applies to</span>
<span class="sd">        the given set of assumptions (its assumptions are a subset</span>
<span class="sd">        of the given assumptions).  Return None if there is no match.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">expression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">lookup_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">truths</span> <span class="o">=</span> <span class="n">KnownTruth</span><span class="o">.</span><span class="n">lookup_dict</span><span class="p">[</span><span class="n">expression</span><span class="p">]</span>
        <span class="n">suitableTruths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">truth</span> <span class="ow">in</span> <span class="n">truths</span><span class="p">:</span>
            <span class="n">proof</span> <span class="o">=</span> <span class="n">truth</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proof</span><span class="o">.</span><span class="n">isUsable</span><span class="p">()</span> <span class="ow">and</span> <span class="n">truth</span><span class="o">.</span><span class="n">assumptionsSet</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">assumptionsSet</span><span class="p">):</span>
                <span class="n">suitableTruths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suitableTruths</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span> <span class="c1"># no suitable truth</span>
        <span class="c1"># return one wih the shortest proof, and among those the fewest assumptions</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">suitableTruths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">truth</span> <span class="p">:</span> <span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span><span class="o">.</span><span class="n">numSteps</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)))</span></div>
    
<div class="viewcode-block" id="KnownTruth.forgetKnownTruths"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.forgetKnownTruths">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">forgetKnownTruths</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Forget all KnownTruth&#39;s and all Assumption proof objects.  This is used</span>
<span class="sd">        for demonstration purposes in the tutorial, but should not generally be needed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proof</span> <span class="k">import</span> <span class="n">Assumption</span>
        <span class="n">KnownTruth</span><span class="o">.</span><span class="n">lookup_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">Assumption</span><span class="o">.</span><span class="n">allAssumptions</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>
    
    <span class="k">def</span> <span class="nf">_checkedTruth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">):</span>
        <span class="n">proven_truth</span> <span class="o">=</span> <span class="n">proof</span><span class="o">.</span><span class="n">provenTruth</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">proven_truth</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span>
            <span class="n">proven_truth</span><span class="o">.</span><span class="n">raiseUnusableProof</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">proven_truth</span>        
        
<div class="viewcode-block" id="KnownTruth.relabel"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relabelMap</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a relabeling derivation step, deriving another KnownTruth</span>
<span class="sd">        from this KnownTruth, under the same assumptions, with relabeled</span>
<span class="sd">        Variables.  A Variable may only be relabeled to a Variable.</span>
<span class="sd">        Returns the proven relabeled KnownTruth, or throws an exception if the proof fails.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">Specialization</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span><span class="n">Specialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numForallEliminations</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">relabelMap</span><span class="o">=</span><span class="n">relabelMap</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="KnownTruth.specialize"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.specialize">[docs]</a>    <span class="k">def</span> <span class="nf">specialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specializeMap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relabelMap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">USE_DEFAULTS</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a specialize derivation step to be proven under the given</span>
<span class="sd">        assumptions, in addition to the assumptions of the KnownTruth.</span>
<span class="sd">        This will eliminate one or more nested Forall operations, specializing</span>
<span class="sd">        the instance variables according to specializeMap.  Eliminates</span>
<span class="sd">        the number of Forall operations required to utilize all of the</span>
<span class="sd">        specializeMap keys.  The default mapping of all instance variables</span>
<span class="sd">        is a mapping to itself (e.g., {x:x, y:y}).  Simultaneously, variables </span>
<span class="sd">        may be relabeled via relabelMap (see the relabel method).  Note, there </span>
<span class="sd">        is a difference between  making substitutons simultaneously versus </span>
<span class="sd">        in-series.  For example, the {x:y, y:x} mapping will swap x and y </span>
<span class="sd">        variables, but mapping {x:y} then {y:x} in series would set both </span>
<span class="sd">        variables to x.</span>
<span class="sd">        Returns the proven specialized KnownTruth, or throws an exception if the</span>
<span class="sd">        proof fails.        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">singleOrCompositeExpression</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Forall</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">Specialization</span><span class="p">,</span> <span class="n">SpecializationFailure</span><span class="p">,</span> <span class="n">ProofFailure</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span>
            <span class="c1"># If this KnownTruth is not usable, see if there is an alternate under the</span>
            <span class="c1"># set of assumptions that is usable.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">alternate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">automation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ProofFailure</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raiseUnusableProof</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">alternate</span><span class="o">.</span><span class="n">specialize</span><span class="p">(</span><span class="n">specializeMap</span><span class="p">,</span> <span class="n">relabelMap</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">)</span>
        
        <span class="c1"># if no specializeMap is provided, specialize the &quot;explicitInstanceVars&quot; of the Forall with default mappings </span>
        <span class="c1"># (mapping instance variables to themselves)</span>
        <span class="k">if</span> <span class="n">specializeMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">specializeMap</span> <span class="o">=</span> <span class="p">{</span><span class="n">ivar</span><span class="p">:</span><span class="n">ivar</span> <span class="k">for</span> <span class="n">ivar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">explicitInstanceVars</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">relabelMap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">relabelMap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
        <span class="c1"># Include the KnownTruth assumptions along with any provided assumptions</span>
        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">checkedAssumptions</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">assumptions</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span>

        <span class="c1"># For any entrys in the subMap with Operation keys, convert</span>
        <span class="c1"># them to corresponding operator keys with Lambda substitutions.</span>
        <span class="c1"># For example f(x,y):g(x,y) would become f:[(x,y) -&gt; g(x,y)].</span>
        <span class="c1"># Convert to composite expressions as needed (via singleOrCompositeExpression).</span>
        <span class="n">processedSubMap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">specializeMap</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">singleOrCompositeExpression</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                <span class="n">operation</span> <span class="o">=</span> <span class="n">key</span>
                <span class="n">subVar</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">operator</span>
                <span class="n">sub</span> <span class="o">=</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
                <span class="n">processedSubMap</span><span class="p">[</span><span class="n">subVar</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">processedSubMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SpecializationFailure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="s1">&#39;Expecting specializeMap keys to be Variables, MultiVariables, or Operations with Variable/MultiVariable operators; not </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="n">remainingSubVars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">processedSubMap</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="c1"># Determine the number of Forall eliminations.  There must be at least</span>
        <span class="c1"># one (if zero is desired, relabel should be called instead).</span>
        <span class="c1"># The number is determined by the instance variables that occur as keys</span>
        <span class="c1"># in the subMap.</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
        <span class="n">numForallEliminations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">numForallEliminations</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">remainingSubVars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">numForallEliminations</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Forall</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SpecializationFailure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="s1">&#39;May only specialize instance variables of directly nested Forall operations&#39;</span><span class="p">)</span>
            <span class="n">lambdaExpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lambdaExpr</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">),</span> <span class="s2">&quot;Forall Operation operand must be a Lambda function&quot;</span>
            <span class="n">instanceVars</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">conditions</span>  <span class="o">=</span> <span class="n">lambdaExpr</span><span class="o">.</span><span class="n">parameterVars</span><span class="p">,</span> <span class="n">lambdaExpr</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">lambdaExpr</span><span class="o">.</span><span class="n">conditions</span>
            <span class="k">for</span> <span class="n">iVar</span> <span class="ow">in</span> <span class="n">instanceVars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iVar</span> <span class="ow">in</span> <span class="n">remainingSubVars</span><span class="p">:</span>
                    <span class="c1"># remove this instance variable from the remaining substitution variables</span>
                    <span class="n">remainingSubVars</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iVar</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">iVar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processedSubMap</span><span class="p">:</span>
                    <span class="c1"># default is to map instance variables to themselves</span>
                    <span class="n">processedSubMap</span><span class="p">[</span><span class="n">iVar</span><span class="p">]</span> <span class="o">=</span> <span class="n">iVar</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span><span class="n">Specialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numForallEliminations</span><span class="o">=</span><span class="n">numForallEliminations</span><span class="p">,</span> <span class="n">specializeMap</span><span class="o">=</span><span class="n">processedSubMap</span><span class="p">,</span> <span class="n">relabelMap</span><span class="o">=</span><span class="n">relabelMap</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="KnownTruth.generalize"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.generalize">[docs]</a>    <span class="k">def</span> <span class="nf">generalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forallVarLists</span><span class="p">,</span> <span class="n">domainLists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conditions</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a generalization derivation step.  Returns the</span>
<span class="sd">        proven generalized KnownTruth.  Can introduce any number of</span>
<span class="sd">        nested Forall operations to wrap the original statement,</span>
<span class="sd">        corresponding to the number of given forallVarLists and domains.</span>
<span class="sd">        A single variable list or single variable and a single domain may </span>
<span class="sd">        be provided to introduce a single Forall wrapper.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">Generalization</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">compositeExpression</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">InSet</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">forallVarLists</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="n">forallVarLists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">forallVarLists</span><span class="p">]]</span> <span class="c1"># a single Variable to convert into a list of variable lists</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">forallVarLists</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply &#39;generalize&#39; with a Variable, list of Variables, or list of Variable lists.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">forallVarLists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide at least one Variable to generalize over&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">forallVarLists</span><span class="p">):</span>
                <span class="c1"># convert a list of Variable/MultiVariables to a list of lists</span>
                <span class="n">forallVarLists</span> <span class="o">=</span> <span class="p">[</span><span class="n">forallVarLists</span><span class="p">]</span>
        
        <span class="c1"># Add domain conditions as appropriate</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">domainLists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either specify a &#39;domain&#39; or a list of &#39;domainLists&#39; but not both&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domainLists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">domain</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">forallVarList</span><span class="p">)</span> <span class="k">for</span> <span class="n">forallVarList</span> <span class="ow">in</span> <span class="n">forallVarLists</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">domainLists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domainConditions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">domainList</span><span class="p">,</span> <span class="n">forallVarList</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">domainLists</span><span class="p">,</span> <span class="n">forallVarLists</span><span class="p">):</span>
                <span class="n">domainList</span> <span class="o">=</span> <span class="n">compositeExpression</span><span class="p">(</span><span class="n">domainList</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domainList</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">domainList</span> <span class="o">=</span> <span class="p">[</span><span class="n">domainList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">forallVarList</span><span class="p">)</span>
                <span class="n">domainConditions</span> <span class="o">+=</span> <span class="p">[</span><span class="n">InSet</span><span class="p">(</span><span class="n">instanceVar</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span> <span class="k">for</span> <span class="n">instanceVar</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">forallVarList</span><span class="p">,</span> <span class="n">domainList</span><span class="p">)]</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="n">domainConditions</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span><span class="n">Generalization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forallVarLists</span><span class="p">,</span> <span class="n">conditions</span><span class="p">))</span></div>

<div class="viewcode-block" id="KnownTruth.asImplication"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.asImplication">[docs]</a>    <span class="k">def</span> <span class="nf">asImplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Performs a hypothetical reasoning derivation step, forming an</span>
<span class="sd">        implication statement with the given hypothesis and this statement</span>
<span class="sd">        as the conclusion.  The hypothesis is removed from the set of</span>
<span class="sd">        the conclusion statement&#39;s assumptions for the implication</span>
<span class="sd">        statement&#39;s assumptions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit._core_.proof</span> <span class="k">import</span> <span class="n">HypotheticalReasoning</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">,</span> <span class="n">KnownTruth</span><span class="p">):</span>
            <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">hypothesis</span><span class="o">.</span><span class="n">expr</span> <span class="c1"># we want the expression for this purpose</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkedTruth</span><span class="p">(</span><span class="n">HypotheticalReasoning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="KnownTruth.evaluation"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.evaluation">[docs]</a>    <span class="k">def</span> <span class="nf">evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calling evaluation on a KnownTruth results in deriving that its</span>
<span class="sd">        expression is equal to TRUE, under the assumptions of the KnownTruth.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">evaluateTruth</span>
        <span class="k">return</span> <span class="n">evaluateTruth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span></div>

<div class="viewcode-block" id="KnownTruth.asImpl"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.asImpl">[docs]</a>    <span class="k">def</span> <span class="nf">asImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Abbreviation for asImplication.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asImplication</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span></div>

<div class="viewcode-block" id="KnownTruth.raiseUnusableProof"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.raiseUnusableProof">[docs]</a>    <span class="k">def</span> <span class="nf">raiseUnusableProof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.proof</span> <span class="k">import</span> <span class="n">UnusableProof</span><span class="p">,</span> <span class="n">Theorem</span><span class="p">,</span> <span class="n">Axiom</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proof</span><span class="p">()</span>
        <span class="n">unusuable_proof</span> <span class="o">=</span> <span class="n">proof</span><span class="o">.</span><span class="n">_meaningData</span><span class="o">.</span><span class="n">_unusableProof</span>
        <span class="k">if</span> <span class="n">proof</span> <span class="o">==</span> <span class="n">unusuable_proof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnusableProof</span><span class="p">(</span><span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span><span class="p">,</span> <span class="n">unusuable_proof</span><span class="p">)</span>        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnusableProof</span><span class="p">(</span><span class="n">KnownTruth</span><span class="o">.</span><span class="n">theoremBeingProven</span><span class="p">,</span> <span class="n">unusuable_proof</span><span class="p">,</span> <span class="s1">&#39;required to prove&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">performUsabilityCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> </div>

<div class="viewcode-block" id="KnownTruth.string"><a class="viewcode-back" href="../../../api/proveit.KnownTruth.html#proveit.KnownTruth.string">[docs]</a>    <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">performUsabilityCheck</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If the KnownTruth was proven under any assumptions, display the </span>
<span class="sd">        double-turnstyle notation to show that the set of assumptions proves</span>
<span class="sd">        the statement/expression.  Otherwise, simply display the expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">ExprList</span>
        <span class="k">if</span> <span class="n">performUsabilityCheck</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseUnusableProof</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">assumptionsStr</span> <span class="o">=</span> <span class="n">ExprList</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;{&#39;</span> <span class="o">+</span><span class="n">assumptionsStr</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;} |= &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;|= &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">string</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string representation of the KnownTruth.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string representation of the KnownTruth.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseUnusableProof</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate html to show the KnownTruth as a set of assumptions,</span>
<span class="sd">        turnstile, then the statement expression.  Expressions are png&#39;s</span>
<span class="sd">        compiled from the latex (that may be recalled from memory or storage </span>
<span class="sd">        if previously generated) with a links to</span>
<span class="sd">        expr.ipynb notebooks for displaying the expression information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Set</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isUsable</span><span class="p">():</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseUnusableProof</span><span class="p">()</span>
        <span class="n">html</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;span style=&quot;font-size:20px;&quot;&gt;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">html</span> <span class="o">+=</span> <span class="n">Set</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">assumptions</span><span class="p">)</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39; &amp;#x22A2;&amp;nbsp;&#39;</span> <span class="c1"># turnstile symbol</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/span&gt;&#39;</span>
        <span class="k">return</span> <span class="n">html</span></div>

<div class="viewcode-block" id="asExpression"><a class="viewcode-back" href="../../../api/proveit.asExpression.html#proveit.asExpression">[docs]</a><span class="k">def</span> <span class="nf">asExpression</span><span class="p">(</span><span class="n">truthOrExpression</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the argument as Expressions.  That is, if the argument is the</span>
<span class="sd">    KnownTruth, yield its associated Expression.  If it is an Expression,</span>
<span class="sd">    yield just that.  Otherwise, raise a TypeError.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truthOrExpression</span><span class="p">,</span> <span class="n">KnownTruth</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">truthOrExpression</span><span class="o">.</span><span class="n">expr</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">truthOrExpression</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">truthOrExpression</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected to be a KnownTruth or an Expression&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="asExpressions"><a class="viewcode-back" href="../../../api/proveit.asExpressions.html#proveit.asExpressions">[docs]</a><span class="k">def</span> <span class="nf">asExpressions</span><span class="p">(</span><span class="o">*</span><span class="n">truthOrExpressions</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the arguments as a list of Expressions via asExpression.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">asExpression</span><span class="p">(</span><span class="n">truthOrExpression</span><span class="p">)</span> <span class="k">for</span> <span class="n">truthOrExpression</span> <span class="ow">in</span> <span class="n">truthOrExpression</span><span class="p">]</span></div>

<span class="k">class</span> <span class="nc">ProofInitiationFailure</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.asExpression.html">asExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.asExpressions.html">asExpressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.compositeExpression.html">compositeExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.expressionDepth.html">expressionDepth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.maybeFenced.html">maybeFenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.maybeFencedLatex.html">maybeFencedLatex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.maybeFencedString.html">maybeFencedString</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.safeDefaultOrDummyVar.html">safeDefaultOrDummyVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.safeDummyVar.html">safeDummyVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.singleOrCompositeExpression.html">singleOrCompositeExpression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.varIter.html">varIter</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Context.html">Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ContextException.html">ContextException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprList.html">ExprList</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprListError.html">ExprListError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ExprTensor.html">ExprTensor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.HypotheticalReasoning.html">HypotheticalReasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ImproperRelabeling.html">ImproperRelabeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ImproperSubstitution.html">ImproperSubstitution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Indexed.html">Indexed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.IndexedError.html">IndexedError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Iter.html">Iter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.KnownTruth.html">KnownTruth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.LambdaError.html">LambdaError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.OperationSequence.html">OperationSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ParameterExtractionError.html">ParameterExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.RelabelingFailure.html">RelabelingFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.ScopingViolation.html">ScopingViolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Specialization.html">Specialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.SpecializationFailure.html">SpecializationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.TransitiveSequence.html">TransitiveSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.Variable.html">Variable</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.concludeViaImplication.html">concludeViaImplication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.defaultSimplification.html">defaultSimplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.evaluateTruth.html">evaluateTruth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.inBool.html">inBool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.isIrreducibleValue.html">isIrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.reduceOperands.html">reduceOperands</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Membership.html">Membership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Nonmembership.html">Nonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.NotSupersetEq.html">NotSupersetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Subset.html">Subset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Superset.html">Superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.SupersetEq.html">SupersetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.logic.Union.html">Union</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Frac.html">Frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.GreaterEqOnlySeq.html">GreaterEqOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.GreaterOnlySeq.html">GreaterOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.LessEqOnlySeq.html">LessEqOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.LessOnlySeq.html">LessOnlySeq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.greaterSequence.html">greaterSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.isLiteralInt.html">isLiteralInt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.lesserSequence.html">lesserSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.num.html">num</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Greater.html">Greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.GreaterEq.html">GreaterEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.GreaterSequence.html">GreaterSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Len.html">Len</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.LesserSequence.html">LesserSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Sqrt.html">Sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Subtract.html">Subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/proveit.number.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../proveit.html">proveit</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>